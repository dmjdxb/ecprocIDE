/**
 * Code Generators for ecproc formats
 * - YAML (.ecproc)
 * - Python SDK
 * - ECDL JSON
 * - Faraday IR JSON
 */

import { TECHNIQUES } from './techniques';

/**
 * Generate .ecproc YAML format
 */
export function generateYAML(metadata, steps) {
  const m = {
    ...metadata,
    name: sanitizeString(metadata.name),
    author: sanitizeString(metadata.author),
    description: sanitizeString(metadata.description),
    electrolyte: sanitizeString(metadata.electrolyte),
  };
  const lines = [];

  // Header comment
  lines.push('# ecproc — Electrochemical Procedure');
  lines.push(`# Generated by ecproc IDE on ${new Date().toISOString().split('T')[0]}`);
  lines.push('');

  // Metadata section
  lines.push('metadata:');
  lines.push(`  protocol: "${escapeYaml(m.name)}"`);
  lines.push('  version: "1.0"');
  if (m.author) lines.push(`  author: "${escapeYaml(m.author)}"`);
  if (m.description) lines.push(`  description: "${escapeYaml(m.description)}"`);
  lines.push('');

  // System section
  lines.push('system:');
  lines.push(`  electrodes: ${m.electrodes}`);
  lines.push(`  reference: ${m.reference}`);
  if (m.electrolyte) lines.push(`  electrolyte: "${escapeYaml(m.electrolyte)}"`);
  if (m.temperature) lines.push(`  temperature: ${m.temperature} °C`);
  if (m.working_electrode) lines.push(`  working_electrode: "${escapeYaml(m.working_electrode)}"`);
  if (m.counter_electrode) lines.push(`  counter_electrode: "${escapeYaml(m.counter_electrode)}"`);
  lines.push('');
  
  // Procedure section
  lines.push('procedure:');
  lines.push('  - name: Main');
  lines.push('    steps:');
  
  steps.forEach((step, index) => {
    const tech = TECHNIQUES[step.technique];
    lines.push(`      # Step ${index + 1}: ${tech.name}`);
    lines.push(`      - ${step.technique}:`);
    
    Object.entries(step.params).forEach(([key, value]) => {
      if (value !== null && value !== '' && value !== undefined) {
        const paramDef = tech.params[key];
        const cleanKey = key.replace(/_[A-Za-z_]+$/, ''); // Remove unit suffix
        const unit = paramDef?.unit && !key.includes('_') ? ` ${paramDef.unit}` : '';
        
        if (typeof value === 'boolean') {
          lines.push(`          ${cleanKey}: ${value}`);
        } else if (typeof value === 'string' && isNaN(value)) {
          lines.push(`          ${cleanKey}: "${value}"`);
        } else {
          lines.push(`          ${cleanKey}: ${value}${unit}`);
        }
      }
    });
    
    if (step.tag) {
      lines.push(`        tag: "${escapeYaml(step.tag)}"`);
    }
  });
  
  return lines.join('\n');
}

/**
 * Generate Python SDK code
 */
export function generatePython(metadata, steps) {
  const m = {
    ...metadata,
    name: sanitizeString(metadata.name),
    author: sanitizeString(metadata.author),
    description: sanitizeString(metadata.description),
    electrolyte: sanitizeString(metadata.electrolyte),
  };
  const lines = [];

  // Module docstring
  lines.push('"""');
  lines.push(`${m.name}`);
  lines.push('');
  lines.push('Generated by ecproc IDE');
  lines.push(`Date: ${new Date().toISOString().split('T')[0]}`);
  lines.push('"""');
  lines.push('');

  // Imports
  lines.push('from ecproc import Procedure');
  lines.push('');

  // Create procedure
  lines.push('# Initialize procedure');
  lines.push(`proc = Procedure("${escapePython(m.name)}", version="1.0")`);
  lines.push('');

  // System configuration
  lines.push('# System configuration');
  lines.push('proc.system(');
  lines.push(`    electrodes=${m.electrodes},`);
  lines.push(`    reference="${m.reference}",`);
  if (m.electrolyte) lines.push(`    electrolyte="${escapePython(m.electrolyte)}",`);
  if (m.temperature) lines.push(`    temperature=${m.temperature},`);
  if (m.working_electrode) lines.push(`    working_electrode="${escapePython(m.working_electrode)}",`);
  lines.push(')');
  lines.push('');
  
  // Main phase
  lines.push('# Procedure steps');
  lines.push('with proc.phase("Main") as p:');
  
  steps.forEach((step, index) => {
    const tech = TECHNIQUES[step.technique];
    lines.push(`    # Step ${index + 1}: ${tech.name}`);
    
    // Build parameter string
    const paramPairs = [];
    Object.entries(step.params).forEach(([key, value]) => {
      if (value !== null && value !== '' && value !== undefined) {
        const cleanKey = key.replace(/_[A-Za-z_]+$/, ''); // Remove unit suffix
        if (typeof value === 'boolean') {
          paramPairs.push(`${cleanKey}=${value ? 'True' : 'False'}`);
        } else if (typeof value === 'string' && isNaN(value)) {
          paramPairs.push(`${cleanKey}="${escapePython(value)}"`);
        } else {
          paramPairs.push(`${cleanKey}=${value}`);
        }
      }
    });
    
    if (step.tag) {
      paramPairs.push(`tag="${escapePython(step.tag)}"`);
    }
    
    const paramsStr = paramPairs.join(', ');
    lines.push(`    p.${step.technique}(${paramsStr})`);
    lines.push('');
  });
  
  // Validation and compilation
  lines.push('# Validate procedure');
  lines.push('result = proc.validate()');
  lines.push('if not result.passed:');
  lines.push('    for issue in result.issues:');
  lines.push('        print(f"[{issue.code}] {issue.message}")');
  lines.push('    raise ValueError("Procedure validation failed")');
  lines.push('');
  lines.push('# Compile to target');
  lines.push('# proc.compile(target="python")  # Generate executable');
  lines.push('# proc.compile(target="manual")  # Generate lab manual PDF');
  lines.push('');
  lines.push('print(f"Procedure \'{proc.name}\' ready with {len(proc.phases[0].steps)} steps")');
  
  return lines.join('\n');
}

/**
 * Generate ECDL JSON format
 */
export function generateECDL(metadata, steps) {
  const now = new Date().toISOString();
  
  const ecdl = {
    ecdl_version: "1.0.0",
    id: `ecdl-${Date.now()}`,
    
    material: {
      formula_raw: "[MATERIAL_FORMULA]",
      formula_canonical: null,
      composition: {},
      phase: "unknown",
      morphology: "unknown",
      // To be filled after experiment
    },
    
    protocol: {
      electrolyte: metadata.electrolyte ? {
        type: inferElectrolyteType(metadata.electrolyte),
        formula: metadata.electrolyte,
        concentration_M: inferConcentration(metadata.electrolyte),
      } : null,
      ph: inferPH(metadata.electrolyte),
      regime: inferRegime(metadata.electrolyte),
      temperature_C: metadata.temperature || null,
      test_format: "THREE_ELECTRODE",
      reference_electrode_type: metadata.reference,
      cell_configuration: metadata.electrodes === 3 ? "three_electrode" : "two_electrode",
      // Derived from steps
      duration_hours: estimateDuration(steps),
      cycle_count: estimateCycles(steps),
    },
    
    observation: {
      metric_type: "OTHER",
      value: null,
      unit: null,
      // To be filled after experiment with measured values
    },
    
    hazard: {
      severity_index: null,
      components: {},
      // Computed by ECDL validator
    },
    
    completeness: {
      physics_completeness: null,
      reporting_completeness: null,
      // Computed by ECDL validator
    },
    
    provenance: {
      title: metadata.name,
      extraction_date: now,
      extractor_version: "ecproc-ide-1.0.0",
      verification_status: "unverified",
    },
    
    // Non-standard: procedure definition for reproducibility
    _procedure: {
      name: metadata.name,
      version: "1.0",
      system: {
        electrodes: metadata.electrodes,
        reference: metadata.reference,
        electrolyte: metadata.electrolyte,
        temperature_C: metadata.temperature,
        working_electrode: metadata.working_electrode,
        counter_electrode: metadata.counter_electrode,
      },
      steps: steps.map((step, index) => ({
        order: index + 1,
        technique: step.technique,
        technique_name: TECHNIQUES[step.technique]?.name,
        params: step.params,
        tag: step.tag || null,
      })),
    },
    
    metadata: {
      created_at: now,
      updated_at: now,
      tags: extractTags(metadata, steps),
      notes: `Generated by ecproc IDE. Material and observation fields should be populated after experimental execution.`,
    },
  };
  
  return JSON.stringify(ecdl, null, 2);
}

/**
 * Generate Faraday IR JSON format
 */
export function generateIR(metadata, steps) {
  const now = new Date().toISOString();
  
  const ir = {
    faraday_version: "1.0",
    
    metadata: {
      protocol: metadata.name,
      version: "1.0",
      created: now,
      ecproc_version: "1.0.0",
      source_hash: generateHash(metadata, steps),
      author: metadata.author || null,
    },
    
    system: {
      electrodes: metadata.electrodes,
      reference: metadata.reference,
      working: metadata.working_electrode ? {
        material: metadata.working_electrode,
        area_m2: null, // Would need to be specified
        loading_kg_m2: null,
      } : null,
      electrolyte: metadata.electrolyte ? {
        solute: inferElectrolyteType(metadata.electrolyte),
        concentration_mol_m3: (inferConcentration(metadata.electrolyte) || 0) * 1000, // M to mol/m³
      } : null,
      counter: metadata.counter_electrode || null,
    },
    
    procedure: [
      {
        name: "Main",
        setup: null,
        stabilize: null,
        steps: steps.map(step => convertStepToIR(step)),
        teardown: null,
      }
    ],
    
    safety: {
      max_current_A: null,
      voltage_window_V: null,
      temperature_limits_C: metadata.temperature ? [metadata.temperature - 5, metadata.temperature + 5] : null,
      stop_conditions: null,
    },
    
    state_recovery: null,
    variables: null,
    output: null,
    
    provenance: {
      source_file: null,
      source_hash: generateHash(metadata, steps),
      parser_version: "ecproc-ide-1.0.0",
    },
  };
  
  return JSON.stringify(ir, null, 2);
}

// === Helper Functions ===

export function sanitizeString(str, maxLength = 500) {
  if (!str) return '';
  // eslint-disable-next-line no-control-regex
  return String(str).slice(0, maxLength).replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
}

export function escapeYaml(str) {
  if (!str) return '';
  return str.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
}

export function escapePython(str) {
  if (!str) return '';
  return str.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t');
}

function inferElectrolyteType(electrolyte) {
  if (!electrolyte) return 'UNKNOWN';
  const e = electrolyte.toUpperCase();
  if (e.includes('H2SO4')) return 'H2SO4';
  if (e.includes('HCLO4')) return 'HClO4';
  if (e.includes('HCL')) return 'HCl';
  if (e.includes('KOH')) return 'KOH';
  if (e.includes('NAOH')) return 'NaOH';
  if (e.includes('PBS')) return 'PBS';
  if (e.includes('NAFION')) return 'NAFION';
  return 'OTHER';
}

function inferConcentration(electrolyte) {
  if (!electrolyte) return null;
  const match = electrolyte.match(/(\d+\.?\d*)\s*M/i);
  return match ? parseFloat(match[1]) : null;
}

function inferPH(electrolyte) {
  if (!electrolyte) return null;
  const type = inferElectrolyteType(electrolyte);
  const conc = inferConcentration(electrolyte) || 0.1;
  
  // Rough pH estimates
  if (['H2SO4', 'HClO4', 'HCl'].includes(type)) {
    return Math.max(0, -Math.log10(conc * (type === 'H2SO4' ? 2 : 1)));
  }
  if (['KOH', 'NaOH'].includes(type)) {
    return Math.min(14, 14 + Math.log10(conc));
  }
  if (type === 'PBS') return 7.4;
  return null;
}

function inferRegime(electrolyte) {
  const ph = inferPH(electrolyte);
  if (ph === null) return 'unknown';
  if (ph < 4) return 'acidic';
  if (ph > 10) return 'alkaline';
  return 'neutral';
}

function estimateDuration(steps) {
  let seconds = 0;
  steps.forEach(step => {
    if (step.params.duration_s) seconds += parseFloat(step.params.duration_s) || 0;
    if (step.params.duration_min) seconds += (parseFloat(step.params.duration_min) || 0) * 60;
    // Estimate CV/LSV time
    if (step.technique === 'cv') {
      const range = Math.abs((step.params.vertex2_V || 1.2) - (step.params.vertex1_V || 0.05));
      const rate = (step.params.scan_rate_mV_s || 50) / 1000; // V/s
      const cycles = step.params.cycles || 3;
      seconds += (2 * range / rate) * cycles;
    }
    if (step.technique === 'lsv') {
      const range = Math.abs((step.params.end_V || 0.2) - (step.params.start_V || 1.0));
      const rate = (step.params.scan_rate_mV_s || 5) / 1000;
      seconds += range / rate;
    }
    if (step.technique === 'eis') {
      // Rough EIS time estimate: ~2-5 min typical
      seconds += 180;
    }
  });
  return Math.round(seconds / 3600 * 100) / 100; // Hours with 2 decimals
}

function estimateCycles(steps) {
  let total = 0;
  steps.forEach(step => {
    if (step.params.cycles) total += parseInt(step.params.cycles) || 0;
  });
  return total || null;
}

function extractTags(metadata, steps) {
  const tags = [];
  
  // From electrolyte
  const regime = inferRegime(metadata.electrolyte);
  if (regime !== 'unknown') tags.push(regime);
  
  // From techniques
  const techniques = [...new Set(steps.map(s => s.technique))];
  techniques.forEach(t => {
    if (t === 'lsv') tags.push('polarization');
    if (t === 'cv') tags.push('voltammetry');
    if (t === 'eis') tags.push('impedance');
    if (t === 'ca') tags.push('chronoamperometry');
  });
  
  // From step tags
  steps.forEach(s => {
    if (s.tag) tags.push(s.tag);
  });
  
  return [...new Set(tags)];
}

function convertStepToIR(step) {
  const irStep = {
    technique: step.technique,
    tag: step.tag || null,
    extract: null,
    vendor_flags: null,
  };
  
  // Convert params to SI units for IR
  Object.entries(step.params).forEach(([key, value]) => {
    if (value === null || value === undefined || value === '') return;
    
    // Convert to SI base units
    if (key.endsWith('_mV_s')) {
      // mV/s to V/s
      irStep[key.replace('_mV_s', '_V_s')] = parseFloat(value) / 1000;
    } else if (key.endsWith('_mV')) {
      // mV to V
      irStep[key.replace('_mV', '_V')] = parseFloat(value) / 1000;
    } else if (key.endsWith('_min')) {
      // min to s
      irStep[key.replace('_min', '_s')] = parseFloat(value) * 60;
    } else if (key.endsWith('_mA')) {
      // mA to A
      irStep[key.replace('_mA', '_A')] = parseFloat(value) / 1000;
    } else {
      irStep[key] = value;
    }
  });
  
  return irStep;
}

function generateHash(metadata, steps) {
  // Simple hash for demo - in production use crypto
  const content = JSON.stringify({ metadata, steps });
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16).padStart(8, '0');
}
